name: Unified CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
    - 'down/**'
    - 'frontend/**'
    - 'terraform/**'
    - '.github/workflows/unified-deploy.yml'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      action:
        description: 'Terraform action'
        required: true
        default: 'apply'
        type: choice
        options:
        - plan
        - apply
        - destroy
      deploy_static:
        description: 'Deploy static files'
        required: false
        default: true
        type: boolean
      deploy_ecs:
        description: 'Deploy to ECS'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: game-server
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER || 'heebin-cluster' }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE || 'heebin-backend-service' }}
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  TF_VERSION: '1.5.0'

jobs:
  # 1. 빌드 및 테스트
  build-and-test:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Build with Gradle
      run: |
        cd down
        chmod +x gradlew
        ./gradlew build -x test
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: down/build/libs/

  # 2. Docker 이미지 빌드 및 푸시
  docker-build:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
        path: down/build/libs/
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build and push Docker image
      run: |
        cd down
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest .
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

  # 3. 정적 파일 배포 (S3 + CloudFront)

  # 4. 정적 파일 배포 (S3 + CloudFront)
  deploy-static:
    needs: docker-build
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_static == 'true')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
      env:
        REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get S3 bucket name
      id: get-bucket
      run: |
        # GitHub Secrets에서 S3 버킷 이름 가져오기
        BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}"
        
        if [ -z "$BUCKET_NAME" ]; then
          echo "S3 bucket name not found in secrets. Skipping static deployment."
          echo "skip_deploy=true" >> $GITHUB_OUTPUT
        else
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
        fi
        
    - name: Deploy to S3
      if: steps.get-bucket.outputs.skip_deploy != 'true'
      run: |
        # S3에 파일 업로드
        aws s3 sync frontend/ s3://${{ steps.get-bucket.outputs.bucket_name }}/ \
          --delete \
          --cache-control "max-age=31536000,public" \
          --exclude "*.html" \
          --exclude "*.json"
          
        # HTML 파일은 캐시하지 않음
        aws s3 sync frontend/ s3://${{ steps.get-bucket.outputs.bucket_name }}/ \
          --delete \
          --cache-control "no-cache,no-store,must-revalidate" \
          --include "*.html" \
          --include "*.json"
          
        echo "Static files deployed to s3://${{ steps.get-bucket.outputs.bucket_name }}"
        
    - name: Invalidate CloudFront cache
      if: steps.get-bucket.outputs.skip_deploy != 'true'
      run: |
        # CloudFront 배포 ID 가져오기
        DISTRIBUTION_ID=$(aws cloudfront list-distributions \
          --query 'DistributionList.Items[?Comment==`production-cloudfront`].Id' \
          --output text)
          
        if [ ! -z "$DISTRIBUTION_ID" ]; then
          # CloudFront 캐시 무효화
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"
          echo "CloudFront cache invalidated for distribution: $DISTRIBUTION_ID"
        else
          echo "CloudFront distribution not found"
        fi

  # 4.5. Terraform 인프라 배포 (ECS 클러스터 및 서비스)
  deploy-infrastructure:
    needs: [docker-build]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_ecs == 'true')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        
    - name: Terraform Init
      run: |
        cd down/terraform
        terraform init
        
    - name: Terraform Plan
      run: |
        cd down/terraform
        terraform plan -out=tfplan
        
    - name: Terraform Apply
      run: |
        cd down/terraform
        terraform apply -auto-approve tfplan
        
    - name: Wait for ECS cluster to be ready
      run: |
        echo "Waiting for ECS cluster to be active..."
        aws ecs wait cluster-stable --clusters $ECS_CLUSTER || {
          echo "❌ ECS cluster failed to become stable"
          aws ecs describe-clusters --clusters $ECS_CLUSTER
          exit 1
        }
        echo "✅ ECS cluster is now stable"

  # 5. ECS 배포
  deploy-ecs:
    needs: [docker-build, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_ecs == 'true')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Pull and tag image for ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # GitHub Container Registry에서 이미지 가져오기
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # ECR용으로 태그 변경
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # ECR에 푸시
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
    - name: Update ECS service
      run: |
        echo "Updating ECS service with new deployment..."
        
        # 새로운 태스크 정의 생성
        TASK_DEFINITION_ARN=$(aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE \
          --query 'services[0].taskDefinition' \
          --output text)
          
        # 태스크 정의 복사 및 새 이미지로 업데이트
        NEW_TASK_DEFINITION_ARN=$(aws ecs register-task-definition \
          --cli-input-json "$(aws ecs describe-task-definition \
            --task-definition $TASK_DEFINITION_ARN \
            --query 'taskDefinition | {family: family, networkMode: networkMode, requiresCompatibilities: requiresCompatibilities, cpu: cpu, memory: memory, executionRoleArn: executionRoleArn, taskRoleArn: taskRoleArn, containerDefinitions: containerDefinitions}' \
            --output json | jq '.containerDefinitions[0].image = "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"')" \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
          
        # 서비스 업데이트
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition $NEW_TASK_DEFINITION_ARN \
          --force-new-deployment || {
          echo "❌ Failed to update ECS service"
          echo "Checking if service exists and is active..."
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE
          exit 1
        }
        echo "✅ ECS service update initiated"
          
    - name: Check ECS cluster and service status
      run: |
        echo "Checking ECS cluster status..."
        CLUSTER_STATUS=$(aws ecs describe-clusters --clusters $ECS_CLUSTER --query 'clusters[0].status' --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [ "$CLUSTER_STATUS" = "NOT_FOUND" ] || [ "$CLUSTER_STATUS" = "INACTIVE" ]; then
          echo "❌ ECS cluster is not active. Status: $CLUSTER_STATUS"
          echo "Please check your infrastructure deployment or recreate the cluster."
          exit 1
        fi
        
        echo "✅ ECS cluster is active. Status: $CLUSTER_STATUS"
        
        echo "Checking ECS service status..."
        SERVICE_STATUS=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].status' --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [ "$SERVICE_STATUS" = "NOT_FOUND" ]; then
          echo "❌ ECS service not found. Please check your service configuration."
          exit 1
        fi
        
        echo "✅ ECS service found. Status: $SERVICE_STATUS"
        
        # 서비스가 INACTIVE인 경우 활성화 시도
        if [ "$SERVICE_STATUS" = "INACTIVE" ]; then
          echo "🔄 Attempting to activate ECS service..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --desired-count 1 || {
            echo "❌ Failed to activate ECS service"
            exit 1
          }
          echo "✅ ECS service activated"
        fi
        
    - name: Wait for deployment
      run: |
        echo "Waiting for ECS service to become stable..."
        aws ecs wait services-stable \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE || {
          echo "❌ ECS service failed to stabilize"
          echo "Checking service details for troubleshooting..."
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE
          exit 1
        }
        echo "✅ ECS service is now stable"

  # 6. 배포 완료 알림
  deployment-summary:
    needs: [deploy-static, deploy-ecs, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Deployment Summary
      run: |
        echo "## 🚀 배포 완료!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### 🔄 배포된 서비스:" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ 백엔드 API (Docker Image)" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ 프론트엔드 (S3 + CloudFront)" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ ECS 서비스 업데이트" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📝 다음 단계:" >> $GITHUB_STEP_SUMMARY
        echo "1. 애플리케이션 상태 확인" >> $GITHUB_STEP_SUMMARY
        echo "2. 모니터링 설정 확인" >> $GITHUB_STEP_SUMMARY
        echo "3. 로그 확인" >> $GITHUB_STEP_SUMMARY
